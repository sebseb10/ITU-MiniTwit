/*
 * Minitwit API
 *
 * Minitwit API
 *
 * The version of the OpenAPI document: 1.0
 *
 * Generated by: https://openapi-generator.tech
 */

using System.ComponentModel.DataAnnotations;
using Chirp.Core;
using Chirp.Infrastructure;
using Chirp.Infrastructure.Interfaces;
using Chirp.Web.MiniTwit_Stub.Attributes;
using Chirp.Web.MiniTwit_Stub.Models;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Swashbuckle.AspNetCore.Annotations;

namespace Chirp.Web.MiniTwit_Stub.Controllers
{
    [ApiController]
    public class MinitwitApiController : ControllerBase
    {
        private const string SimulatorAuth = "Basic c2ltdWxhdG9yOnN1cGVyX3NhZmUh"; 
        // if using postman : username = simulator Password : super_safe!
        // if using curl
        // curl -k -i -H "Authorization: Basic c2ltdWxhdG9yOnN1cGVyX3NhZmUh" \
        // "wished endpoint"

        private readonly UserManager<Author> _userManager;
        private readonly IAuthorService _authorService;
        private readonly CheepDbContext _db;

        private static int _latestValue = 0;
        private static readonly object _latestLock = new();

        private static void UpdateLatest(int? latest)
        {
            if (!latest.HasValue) return;

            lock (_latestLock)
            {
                _latestValue = latest.Value;
            }
        }

        private static int GetLatest()
        {
            lock (_latestLock) return _latestValue;
        }

        public MinitwitApiController(UserManager<Author> userManager, IAuthorService authorService, CheepDbContext db)
        {
            _userManager = userManager;
            _authorService = authorService;
            _db = db;
        }

        /// <remarks>
        /// Get list of users followed by the given user.
        /// - Query param ?no= limits result count.
        /// - Optionally updates a 'latest' global value via ?latest= query param.
        /// </remarks>
        [HttpGet]
        [Route("/fllws/{username}")]
        [ValidateModelState]
        [SwaggerOperation("GetFollow")]
        [SwaggerResponse(statusCode: 200, type: typeof(FollowsResponse), description: "Success")]
        [SwaggerResponse(statusCode: 403, type: typeof(ErrorResponse), description: "Unauthorized - Must include correct Authorization header")]
        public virtual IActionResult GetFollow(
            [FromRoute(Name = "username")][Required] string username,
            [FromHeader(Name = "Authorization")][Required] string authorization,
            [FromQuery(Name = "latest")] int? latest,
            [FromQuery(Name = "no")] int? no)
        {
            if (authorization != SimulatorAuth)
            {
                return StatusCode(403, new ErrorResponse
                {
                    Status = 403,
                    ErrorMsg = "You are not authorized to access follwed users!"
                });
            }

            UpdateLatest(latest);

            var user = _userManager.FindByNameAsync(username).Result;
            if (user == null)
            {
                return StatusCode(404, new ErrorResponse
                {
                    Status = 404,
                    ErrorMsg = "No user found with this name!"
                });
            }

            var limit = no ?? int.MaxValue;

            var follows = _db.Follows
                .AsNoTracking()
                .Where(f => f.FollowsId == user.Id)
                .Join(
                    _db.Users.AsNoTracking(),
                    f => f.FollowedById,
                    a => a.Id,
                    (f, a) => a.UserName
                )
                .Where(n => !string.IsNullOrWhiteSpace(n))
                .Take(limit)
                .ToList()!;

            return StatusCode(200, new FollowsResponse { Follows = follows });
        }

        /// <remarks>Returns the latest ID saved</remarks>
        [HttpGet]
        [Route("/latest")]
        [ValidateModelState]
        [SwaggerOperation("GetLatestValue")]
        [SwaggerResponse(statusCode: 200, type: typeof(LatestValue), description: "Success")]
        [SwaggerResponse(statusCode: 500, type: typeof(ErrorResponse), description: "Internal Server Error")]
        public virtual IActionResult GetLatestValue()
        {
            try
            {
                return StatusCode(200, new LatestValue { Latest = GetLatest() });
            }
            catch
            {
                return StatusCode(500, new ErrorResponse
                {
                    Status = 500,
                    ErrorMsg = "Internal Server Error"
                });
            }
        }

        /// <remarks>
        /// Get recent messages.
        /// - Returns a list of recent messages (max defined by ?no= param)
        /// - Optionally updates a 'latest' global value via ?latest= query param.
        /// </remarks>
        [HttpGet]
        [Route("/msgs")]
        [ValidateModelState]
        [SwaggerOperation("GetMessages")]
        [SwaggerResponse(statusCode: 200, type: typeof(List<Message>), description: "Success")]
        [SwaggerResponse(statusCode: 403, type: typeof(ErrorResponse), description: "Unauthorized - Must include correct Authorization header")]
        public virtual IActionResult GetMessages(
            [FromHeader(Name = "Authorization")][Required] string authorization,
            [FromQuery(Name = "latest")] int? latest,
            [FromQuery(Name = "no")] int? no)
        {
            if (authorization != SimulatorAuth)
            {
                return StatusCode(403, new ErrorResponse
                {
                    Status = 403,
                    ErrorMsg = "You are not authorized to acsess users Messages!"
                });
            }

            UpdateLatest(latest);

            var limit = no ?? int.MaxValue;

            var msgs = _db.Cheeps
                .AsNoTracking()
                .OrderByDescending(c => c.Timestamp)
                .Take(limit)
                .Select(c => new Chirp.Web.MiniTwit_Stub.Models.Message
                {
                    User = c.Author.UserName,
                    Content = c.Text,
                    PubDate = c.Timestamp.ToString("yyyy-MM-dd HH:mm:ss")
                })
                .ToList();

            return StatusCode(200, msgs);
        }

        /// <remarks>
        /// Get messages for a specific user.
        /// - Returns messages authored by the specified user
        /// - Returns a list of recent messages for the user (max defined by ?no= param)
        /// - Optionally updates a 'latest' global value via ?latest= query param.
        /// </remarks>
        [HttpGet]
        [Route("/msgs/{username}")]
        [ValidateModelState]
        [SwaggerOperation("GetMessagesPerUser")]
        [SwaggerResponse(statusCode: 200, type: typeof(List<Message>), description: "Success")]
        [SwaggerResponse(statusCode: 403, type: typeof(ErrorResponse), description: "Unauthorized - Must include correct Authorization header")]
        public virtual IActionResult GetMessagesPerUser(
            [FromRoute(Name = "username")][Required] string username,
            [FromHeader(Name = "Authorization")][Required] string authorization,
            [FromQuery(Name = "latest")] int? latest,
            [FromQuery(Name = "no")] int? no)
        {
            if (authorization != SimulatorAuth)
            {
                return StatusCode(403, new ErrorResponse
                {
                    Status = 403,
                    ErrorMsg = "You are not authorized to acsess Messages for a speceifc user!"
                });
            }

            UpdateLatest(latest);

            var user = _userManager.FindByNameAsync(username).Result;
            if (user == null)
            {
                return StatusCode(404, new ErrorResponse
                {
                    Status = 404,
                    ErrorMsg = "No user was found with this username!"
                });
            }

            var limit = no ?? int.MaxValue;

            var msgs = _db.Cheeps
                .AsNoTracking()
                .Where(c => c.AuthorID == user.Id)
                .OrderByDescending(c => c.Timestamp)
                .Take(limit)
                .Select(c => new Chirp.Web.MiniTwit_Stub.Models.Message
                {
                    User = username,
                    Content = c.Text,
                    PubDate = c.Timestamp.ToString("yyyy-MM-dd HH:mm:ss")
                })
                .ToList();

            return StatusCode(200, msgs);
        }

        /// <remarks>
        /// Follow or unfollow a user on behalf of username.
        /// - Body must contain either follow: <user> or unfollow: <user>
        /// - Optionally updates a 'latest' global value via ?latest= query param.
        /// </remarks>
        [HttpPost]
        [Route("/fllws/{username}")]
        [Consumes("application/json")]
        [ValidateModelState]
        [SwaggerOperation("PostFollow")]
        [SwaggerResponse(statusCode: 403, type: typeof(ErrorResponse), description: "Unauthorized - Must include correct Authorization header")]
        public virtual async Task<IActionResult> PostFollow(
            [FromRoute(Name = "username")][Required] string username,
            [FromHeader(Name = "Authorization")][Required] string authorization,
            [FromBody] FollowAction payload,
            [FromQuery(Name = "latest")] int? latest)
        {
            if (authorization != SimulatorAuth)
            {
                return StatusCode(403, new ErrorResponse
                {
                    Status = 403,
                    ErrorMsg = "You are not authorized to post follow username"
                });
            }

            UpdateLatest(latest);

            var actor = await _userManager.FindByNameAsync(username);
            if (actor == null)
            {
                return StatusCode(404, new ErrorResponse
                {
                    Status = 404,
                    ErrorMsg = "no such user is found"
                });
            }

            var followTarget = payload?.Follow?.Trim();
            var unfollowTarget = payload?.Unfollow?.Trim();
            var targetName = followTarget ?? unfollowTarget;

            if (string.IsNullOrEmpty(followTarget) == string.IsNullOrEmpty(unfollowTarget))
            {
                return BadRequest(new ErrorResponse
                {
                    Status = 400,
                    ErrorMsg = "Provide exactly one of follow/unfollow."
                });
            }

            var targetUser = await _userManager.FindByNameAsync(targetName!);
            if (targetUser == null)
            {
                return StatusCode(404, new ErrorResponse
                {
                    Status = 404,
                    ErrorMsg = "Cannot follow non existing user"
                });
            }

            var actorId = await _userManager.GetUserIdAsync(actor);
            var targetId = await _userManager.GetUserIdAsync(targetUser);

            if (!string.IsNullOrEmpty(followTarget))
            {
                var exists = await _db.Follows.AnyAsync(f =>
                    f.FollowedById == targetId && f.FollowsId == actorId);

                if (!exists)
                {
                    _db.Follows.Add(new Follows
                    {
                        FollowedById = targetId,
                        FollowsId = actorId
                    });

                    await _db.SaveChangesAsync();
                }
            }
            else
            {
                await _db.Follows
                    .Where(f => f.FollowedById == targetId && f.FollowsId == actorId)
                    .ExecuteDeleteAsync();
            }

            return NoContent();
        }

        /// <remarks>
        /// Post a new message as a specific user.
        /// - Message must include content in the body
        /// - Returns empty body on success
        /// - Optionally updates a 'latest' global value via ?latest= query param.
        /// </remarks>
        [HttpPost]
        [Route("/msgs/{username}")]
        [Consumes("application/json")]
        [ValidateModelState]
        [SwaggerOperation("PostMessagesPerUser")]
        [SwaggerResponse(statusCode: 403, type: typeof(ErrorResponse), description: "Unauthorized - Must include correct Authorization header")]
        public virtual IActionResult PostMessagesPerUser(
            [FromRoute(Name = "username")][Required] string username,
            [FromHeader(Name = "Authorization")][Required] string authorization,
            [FromBody] PostMessage payload,
            [FromQuery(Name = "latest")] int? latest)
        {
            if (authorization != SimulatorAuth)
            {
                return StatusCode(403, new ErrorResponse
                {
                    Status = 403,
                    ErrorMsg = "You are not authorized to post Messages"
                });
            }

            UpdateLatest(latest);

            var user = _userManager.FindByNameAsync(username).Result;
            if (user == null)
            {
                return StatusCode(404, new ErrorResponse
                {
                    Status = 404,
                    ErrorMsg = "no such user is found"
                });
            }

            var content = payload?.Content?.Trim();
            if (string.IsNullOrWhiteSpace(content))
            {
                return BadRequest(new ErrorResponse
                {
                    Status = 400,
                    ErrorMsg = "content is required"
                });
            }

            _db.Cheeps.Add(new Cheep
            {
                AuthorID = user.Id,
                Text = content,
                Timestamp = DateTime.UtcNow
            });

            _db.SaveChanges();

            return NoContent();
        }

        /// <remarks>
        /// Register a new user.
        /// - Optionally updates a 'latest' global value via ?latest= query param.
        /// </remarks>
        [HttpPost]
        [Route("/register")]
        [Consumes("application/json")]
        [ValidateModelState]
        [SwaggerOperation("PostRegister")]
        [SwaggerResponse(statusCode: 400, type: typeof(ErrorResponse),
            description: "Bad Request | Possible reasons:  - missing username  - invalid email  - password missing  - username already taken")]
        [ProducesResponseType(StatusCodes.Status204NoContent)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
        public virtual async Task<IActionResult> PostRegister(
            [FromBody] RegisterRequest payload,
            [FromQuery(Name = "latest")] int? latest)
        {
            UpdateLatest(latest);

            if (payload is null ||
                string.IsNullOrWhiteSpace(payload.Username) ||
                string.IsNullOrWhiteSpace(payload.Email) ||
                string.IsNullOrWhiteSpace(payload.Pwd))
            {
                return BadRequest(new ErrorResponse
                {
                    ErrorMsg = "username, email, and pwd are required",
                    Status = 400
                });
            }

            var existingByName = await _userManager.FindByNameAsync(payload.Username);
            if (existingByName is not null)
            {
                return BadRequest(new ErrorResponse
                {
                    ErrorMsg = "username already exists",
                    Status = 400
                });
            }

            var existingByEmail = await _userManager.FindByEmailAsync(payload.Email);
            if (existingByEmail is not null)
            {
                return BadRequest(new ErrorResponse
                {
                    ErrorMsg = "email already exists",
                    Status = 400
                });
            }

            var user = new Author
            {
                UserName = payload.Username,
                Email = payload.Email
            };

            var result = await _userManager.CreateAsync(user, payload.Pwd);

            if (!result.Succeeded)
            {
                var msg = string.Join("; ", result.Errors.Select(e => e.Description));
                return BadRequest(new ErrorResponse
                {
                    ErrorMsg = msg,
                    Status = 400
                });
            }

            return NoContent();
        }
    }
}